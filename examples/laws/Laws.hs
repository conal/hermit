module Laws where

import Control.Applicative (pure, (<*>), Applicative)
import Control.Monad (liftM)
import Data.Map
import Data.Monoid ((<>), mempty, Monoid(..))

main :: IO ()
main = return ()

-- Since we can't unfold (++)
{-# RULES "append-fix" [~] (++) = myAppend #-}
myAppend :: [a] -> [a] -> [a]
myAppend []     ys = ys
myAppend (x:xs) ys = x : myAppend xs ys

-- Since we can't unfold map
{-# RULES "map-fix" [~] Prelude.map = myMap #-}
myMap :: (a -> b) -> [a] -> [b]
myMap _ []     = []
myMap f (x:xs) = f x : myMap f xs

-- useful auxilliary lemmas
{-# RULES "append-right"   [~] forall x. x ++ [] = x #-}
{-# RULES "pure-singleton" [~] forall x. pure x = [x] #-}
{-# RULES "append-single-left" [~] forall x xs. [x] ++ xs = x:xs #-}
{-# RULES "bind-left-nil"  [~] forall k. [] >>= k = [] #-}
{-# RULES "bind-left-cons" [~] forall x xs k. (x:xs) >>= k = k x ++ (xs >>= k) #-}
{-# RULES "bind-append"    [~] forall m n k. (m >>= k) ++ (n >>= k) = (m ++ n) >>= k #-}
{-# RULES "foldr-id"       [~] Prelude.foldr (:) [] = id #-}
{-# RULES "append-undefined" [~] forall xs. undefined ++ xs = undefined #-}
{-# RULES "ap-nil"         [~] forall f. [f] <*> [] = [] #-}
{-# RULES "ap-cons"        [~] forall f x xs. [f] <*> (x:xs) = f x : ([f] <*> xs) #-}
{-# RULES "nil-ap"         [~] forall xs. [] <*> xs = [] #-}
{-# RULES "cons-ap"        [~] forall f fs xs. (f:fs) <*> xs = ([f] <*> xs) ++ (fs <*> xs) #-}

-- functor
{-# RULES "fmap-id"      [~]             fmap id = id #-}
{-# RULES "fmap-distrib" [~] forall g h. fmap (g.h) = fmap g . fmap h #-}

-- applicative
{-# RULES "identity"     [~] forall v.     pure id <*> v = v #-}
{-# RULES "homomorphism" [~] forall f x.   pure f <*> pure x = pure (f x) #-}
{-# RULES "interchange"  [~] forall u y.   u <*> pure y = pure ($ y) <*> u #-}
{-# RULES "composition"  [~] forall u v w. u <*> (v <*> w) = pure (.) <*> u <*> v <*> w #-}
-- note: switched lhs/rhs to get proper constraints (mention in paper)
{-# RULES "fmap-pure"    [~] forall g x.   pure g <*> x = fmap g x #-}

-- monad
{-# RULES "return-left"  [~] forall k x.   return x >>= k = k x #-}
{-# RULES "return-right" [~] forall k.     k >>= return = k #-}
{-# RULES "bind-assoc"   [~] forall j k l. (j >>= k) >>= l = j >>= (\x -> k x >>= l) #-}

-- note: can only prove this once Applicative is superclass of Monad
-- reason: need both a Monad and Functor constraint on f, but constraints only
-- seem to be generated for left-hand side uses. (This is why fmap-pure and tcompose
-- RULES need to be flipped.) If Applicative was a superclass of Monad,
-- the Monad constraint generated by the following (flipped) ordering
-- would result in the proper Functor constraint needed by the right-hand side
-- because Functor is a superclass of Applicative.
-- {-# RULES "fmap-liftm"   [~] forall f x.   liftM f x = fmap f x #-}

-- this doesn't work because a,b,m don't appear on LHS of RULE.
-- {-# RULES "fmap-liftm"   [~] forall a b m (f :: a -> b) (x :: (Monad m, Functor m) => m a).   liftM f x = fmap f x #-}

-- additional note: maybe this behavior is a bug in typechecking RULES,
-- surely constraints should be collected from both sides and unioned.

-- monoid
{-# RULES "mempty-left"  [~] forall x. mempty <> x = x #-}
{-# RULES "mempty-right" [~] forall x. x <> mempty = x #-}
{-# RULES "mappend-assoc" [~] forall x y z. (x <> y) <> z = x <> (y <> z) #-}
